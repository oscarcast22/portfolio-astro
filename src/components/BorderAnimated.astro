<div class="border-animated" id="border-animated">
    <div class="content">
        <slot />
    </div>
    <div class="border">
        <img src="/images/border-light2.png" alt="Light Border" class="light-mode">
        <img src="/images/border-dark.png" alt="Dark Border" class="dark-mode">
    </div>
</div>

<style>
    .border-animated {
        position: relative;
        padding: 15px;
    }

    .border img {
        position: absolute;
        top: -225px;
        left: -225px;
    }

    .border {
        position: absolute;
        width: 100%;
        height: 100%;
        top: 0;
        left: 0;
        z-index: 1;
        border-radius: 20px;
        mask: 
            linear-gradient(#fff 0 0) content-box, 
            linear-gradient(#fff 0 0);
        mask-composite: exclude;
        -webkit-mask: 
            linear-gradient(#fff 0 0) content-box, 
            linear-gradient(#fff 0 0);
        -webkit-mask-composite: xor;
        padding: 2px;
    }

    .content {
        position: relative;
        z-index: 2;
        color: white;
    }

    .light-mode {
        display: block;
    }

    .dark-mode {
        display: none;
    }

    :root.dark .light-mode {
        display: none;
    }

    :root.dark .dark-mode {
        display: block;
    }
</style>

<script>

    document.addEventListener('astro:page-load', () => {
    const borderContainer = document.querySelector('.border-animated') as HTMLElement;

    const getBorderImage = (): HTMLImageElement => {
        const isDarkMode = document.documentElement.classList.contains('dark');
        return borderContainer.querySelector(`.border img.${isDarkMode ? 'dark-mode' : 'light-mode'}`) as HTMLImageElement;
    };

    let borderImage = getBorderImage();

    const imageWidth: number = 450;
    const imageHeight: number = 450;

    let intervalId: ReturnType<typeof setInterval>;
    let currentState: number = 0;
    const transitionDuration: number = 2500;
    const intervalDelay: number = 1500;

    function moveImageInOrbit(): void {
        clearInterval(intervalId);
        intervalId = setInterval(() => {
            switch (currentState) {
                case 0:
                    borderImage.style.transform = `translate(${borderContainer.offsetWidth}px, -40px)`;
                    break;
                case 1:
                    borderImage.style.transform = `translate(${borderContainer.offsetWidth}px, ${borderContainer.offsetHeight + 40}px)`;
                    break;
                case 2:
                    borderImage.style.transform = `translate(0px, ${borderContainer.offsetHeight + 40}px)`;
                    break;
                case 3:
                    borderImage.style.transform = `translate(-75px, 0px)`;
                    break;
            }

            borderImage.style.transition = `transform ${transitionDuration}ms ease`;

            currentState = (currentState + 1) % 4;
        }, intervalDelay);
    }

    moveImageInOrbit();

    borderContainer.addEventListener('mouseenter', () => {
        clearInterval(intervalId);
        borderImage = getBorderImage();  // Volver a obtener la imagen correcta cuando el usuario interactÃºa
        updateBorderImage(event as MouseEvent);
        borderContainer.addEventListener('mousemove', updateBorderImage);
    });

    borderContainer.addEventListener('mouseleave', () => {
        borderContainer.removeEventListener('mousemove', updateBorderImage);
        moveImageInOrbit();
    });

    function updateBorderImage(e: MouseEvent): void {
        const mouseX: number = e.clientX - borderContainer.offsetLeft + 225;
        const mouseY: number = e.clientY - borderContainer.offsetTop + 225;

        borderImage.style.transform = `translate(${mouseX - imageWidth / 2}px, ${mouseY - imageHeight / 2}px)`;
        borderImage.style.transition = `transform 0.3s ease`;
    }
    })

  </script>
<div class="border-animated" id="border-animated">
    <div class="content">
        <slot />
    </div>
    <div class="border">
        <img src="/images/border-light2.png" alt="Light Border" class="light-mode">
        <img src="/images/border-dark.png" alt="Dark Border" class="dark-mode">
    </div>
</div>

<style>
    .border-animated {
        position: relative;
        padding: 15px;
    }

    .border img {
        position: absolute;
        top: -225px;
        left: -225px;
    }

    .border {
        position: absolute;
        width: 100%;
        height: 100%;
        top: 0;
        left: 0;
        z-index: 1;
        border-radius: 20px;
        mask: 
            linear-gradient(#fff 0 0) content-box, 
            linear-gradient(#fff 0 0);
        mask-composite: exclude;
        -webkit-mask: 
            linear-gradient(#fff 0 0) content-box, 
            linear-gradient(#fff 0 0);
        -webkit-mask-composite: xor;
        padding: 2px;
    }

    .content {
        position: relative;
        z-index: 2;
        color: white;
    }

    .light-mode {
        display: block;
    }

    .dark-mode {
        display: none;
    }

    :root.dark .light-mode {
        display: none;
    }

    :root.dark .dark-mode {
        display: block;
    }
</style>

<script>

    class BorderAnimated {
        borderContainer: HTMLElement;
        borderImage: HTMLImageElement;
        imageWidth: number = 450;
        imageHeight: number = 450;
        intervalId: ReturnType<typeof setInterval> | null = null;
        currentState: number = 0;
        transitionDuration: number;
        intervalDelay: number;

        constructor(borderContainer: HTMLElement) {
            this.borderContainer = borderContainer;
            this.borderImage = this.getBorderImage();
            this.intervalDelay = this.getRandomDelay();
            this.transitionDuration = this.getRandomTransition();

            this.init();
        }

        getRandomDelay(): number {
            return Math.floor(Math.random() * (1800 - 1400 + 1)) + 1400;
        }

        getRandomTransition(): number {
            return Math.floor(Math.random() * (2700 - 2200 + 1)) + 2200;
        }

        getBorderImage(): HTMLImageElement {
            const isDarkMode = document.documentElement.classList.contains('dark');
            return this.borderContainer.querySelector(`.border img.${isDarkMode ? 'dark-mode' : 'light-mode'}`) as HTMLImageElement;
        }

        moveImageInOrbit(): void {
            this.clearOrbit();
            this.intervalId = setInterval(() => {
                switch (this.currentState) {
                    case 0:
                        this.borderImage.style.transform = `translate(${this.borderContainer.offsetWidth}px, -40px)`;
                        break;
                    case 1:
                        this.borderImage.style.transform = `translate(${this.borderContainer.offsetWidth}px, ${this.borderContainer.offsetHeight + 40}px)`;
                        break;
                    case 2:
                        this.borderImage.style.transform = `translate(0px, ${this.borderContainer.offsetHeight + 40}px)`;
                        break;
                    case 3:
                        this.borderImage.style.transform = `translate(-75px, 0px)`;
                        break;
                }

                this.borderImage.style.transition = `transform ${this.transitionDuration}ms ease`;
                this.currentState = (this.currentState + 1) % 4;
            }, this.intervalDelay);
        }

        clearOrbit(): void {
            if (this.intervalId) {
                clearInterval(this.intervalId);
            }
        }

        updateBorderImage(e: MouseEvent): void {
            const mouseX: number = e.clientX - this.borderContainer.offsetLeft + 225;
            const mouseY: number = e.clientY - this.borderContainer.offsetTop + 225;

            this.borderImage.style.transform = `translate(${mouseX - this.imageWidth / 2}px, ${mouseY - this.imageHeight / 2}px)`;
            this.borderImage.style.transition = `transform 0.3s ease`;
        }

        init(): void {
            this.moveImageInOrbit();

            this.borderContainer.addEventListener('mouseenter', () => {
                this.clearOrbit();
                this.borderImage = this.getBorderImage();
                this.updateBorderImage(event as MouseEvent);
                this.borderContainer.addEventListener('mousemove', this.updateBorderImage.bind(this));
            });

            this.borderContainer.addEventListener('mouseleave', () => {
                this.borderContainer.removeEventListener('mousemove', this.updateBorderImage.bind(this));
                this.moveImageInOrbit();
            });
        }
    }

    document.addEventListener('astro:page-load', () => {
        const borderContainers = document.querySelectorAll('.border-animated') as NodeListOf<HTMLElement>;
        borderContainers.forEach((borderContainer) => {
            new BorderAnimated(borderContainer);
        });
    });
    
  </script>
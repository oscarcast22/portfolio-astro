---
interface Props {
    lightBorder?: string | undefined;
    darkBorder?: string | undefined;
}

const { lightBorder = "border-light", darkBorder = "border-dark" } = Astro.props
---
<div class="border-animated" id="border-animated">
    <div class="content">
        <slot />
    </div>
    <div class="border">
        <img src=`/assets/utils/${lightBorder}.png` alt="Light Border" class="light-mode">
        <img src=`/assets/utils/${darkBorder}.png` alt="Dark Border" class="dark-mode">
    </div>
</div>

<style>
    .border-animated {
        position: relative;
        padding: 15px;
    }

    .border img {
        position: absolute;
        top: -225px;
        left: -225px;
    }

    .border {
        position: absolute;
        width: 100%;
        height: 100%;
        top: 0;
        left: 0;
        z-index: 1;
        border-radius: 20px;
        mask: 
            linear-gradient(#fff 0 0) content-box, 
            linear-gradient(#fff 0 0);
        mask-composite: exclude;
        -webkit-mask: 
            linear-gradient(#fff 0 0) content-box, 
            linear-gradient(#fff 0 0);
        -webkit-mask-composite: xor;
        padding: 2px;
    }

    .content {
        position: relative;
        z-index: 2;
        color: white;
    }

    .light-mode {
        display: block;
    }

    .dark-mode {
        display: none;
    }

    :root.dark .light-mode {
        display: none;
    }

    :root.dark .dark-mode {
        display: block;
    }
</style>


<script>
    class BorderAnimated {
        borderContainer: HTMLElement;
        lightImage: HTMLImageElement;
        darkImage: HTMLImageElement;
        imageWidth: number = 450;
        imageHeight: number = 450;
        intervalId: ReturnType<typeof setInterval> | null = null;
        currentState: number = 0;
        transitionDuration: number = 2500;
        intervalDelay: number;
        
        constructor(borderContainer: HTMLElement) {
            this.borderContainer = borderContainer;
            this.lightImage = this.borderContainer.querySelector('.light-mode') as HTMLImageElement;
            this.darkImage = this.borderContainer.querySelector('.dark-mode') as HTMLImageElement;
            this.intervalDelay = this.getRandomDelay();
        
            this.init();
        }
    
        getRandomDelay(): number {
            return Math.floor(Math.random() * (1800 - 1400 + 1)) + 1400;
        }
    
        moveImageInOrbit(): void {
            this.clearOrbit();
            this.intervalId = setInterval(() => {
                let translateX, translateY;
                switch (this.currentState) {
                    case 0:
                        translateX = `${this.borderContainer.offsetWidth}px`;
                        translateY = `-40px`;
                        break;
                    case 1:
                        translateX = `${this.borderContainer.offsetWidth}px`;
                        translateY = `${this.borderContainer.offsetHeight + 40}px`;
                        break;
                    case 2:
                        translateX = `0px`;
                        translateY = `${this.borderContainer.offsetHeight + 40}px`;
                        break;
                    case 3:
                        translateX = `-75px`;
                        translateY = `0px`;
                        break;
                }
            
                this.lightImage.style.transform = `translate(${translateX}, ${translateY})`;
                this.darkImage.style.transform = `translate(${translateX}, ${translateY})`;
            
                this.lightImage.style.transition = `transform ${this.transitionDuration}ms ease`;
                this.darkImage.style.transition = `transform ${this.transitionDuration}ms ease`;
            
                this.currentState = (this.currentState + 1) % 4;
            }, this.intervalDelay);
        }
    
        clearOrbit(): void {
            if (this.intervalId) {
                clearInterval(this.intervalId);
            }
        }
    
        updateBorderImage(e: MouseEvent): void {
            const mouseX: number = e.clientX - this.borderContainer.offsetLeft + 225;
            const mouseY: number = e.clientY - this.borderContainer.offsetTop + 225;
        
            this.lightImage.style.transform = `translate(${mouseX - this.imageWidth / 2}px, ${mouseY - this.imageHeight / 2}px)`;
            this.darkImage.style.transform = `translate(${mouseX - this.imageWidth / 2}px, ${mouseY - this.imageHeight / 2}px)`;
        
            this.lightImage.style.transition = `transform 0.3s ease`;
            this.darkImage.style.transition = `transform 0.3s ease`;
        }
    
        init(): void {
            this.moveImageInOrbit();
        
            this.borderContainer.addEventListener('mouseenter', () => {
                this.clearOrbit();
                this.updateBorderImage(event as MouseEvent);
                this.borderContainer.addEventListener('mousemove', this.updateBorderImage.bind(this));
            });
        
            this.borderContainer.addEventListener('mouseleave', () => {
                this.borderContainer.removeEventListener('mousemove', this.updateBorderImage.bind(this));
                this.moveImageInOrbit();
            });
        }
    }
    
    document.addEventListener('astro:page-load', () => {
        const borderContainers = document.querySelectorAll('.border-animated') as NodeListOf<HTMLElement>;
        
        borderContainers.forEach((borderContainer) => {
            new BorderAnimated(borderContainer);
        });
    });
</script>
